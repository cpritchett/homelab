#!/usr/bin/env bash
set -euo pipefail

# Deploy all stacks in dependency order using simple registry format
# Registry format: stack_name:path:depends_on (comma-separated deps, empty for none)

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
REGISTRY_FILE="${ROOT_DIR}/registry"

if [[ ! -f "${REGISTRY_FILE}" ]]; then
  echo "ERROR: missing stack registry: ${REGISTRY_FILE}" >&2
  exit 1
fi

# Parse registry and build dependency graph
declare -A STACK_PATHS=()
declare -A STACK_DEPS=()
declare -a ALL_STACKS=()

while IFS=':' read -r stack_name path deps_str; do
  # Skip empty lines and comments
  [[ -n "${stack_name}" && "${stack_name}" != \#* ]] || continue
  
  ALL_STACKS+=("${stack_name}")
  STACK_PATHS["${stack_name}"]="${path}"
  
  # Parse dependencies (comma-separated, empty string means no deps)
  if [[ -n "${deps_str}" ]]; then
    IFS=',' read -ra deps_array <<< "${deps_str}"
    STACK_DEPS["${stack_name}"]="${deps_str}"
  else
    STACK_DEPS["${stack_name}"]=""
  fi
done < "${REGISTRY_FILE}"

if [[ ${#ALL_STACKS[@]} -eq 0 ]]; then
  echo "ERROR: no stacks found in registry" >&2
  exit 1
fi

# Validate that all dependencies exist
for stack in "${ALL_STACKS[@]}"; do
  deps="${STACK_DEPS[${stack}]}"
  if [[ -n "${deps}" ]]; then
    IFS=',' read -ra deps_array <<< "${deps}"
    for dep in "${deps_array[@]}"; do
      if [[ -z "${STACK_PATHS[${dep}]:-}" ]]; then
        echo "ERROR: stack '${stack}' depends on unknown stack '${dep}'" >&2
        exit 1
      fi
    done
  fi
done

# Simple topological sort (Kahn's algorithm)
declare -a SORTED_STACKS=()
declare -A IN_DEGREE=()
declare -a QUEUE=()

# Calculate in-degrees
for stack in "${ALL_STACKS[@]}"; do
  IN_DEGREE["${stack}"]=0
done

for stack in "${ALL_STACKS[@]}"; do
  deps="${STACK_DEPS[${stack}]}"
  if [[ -n "${deps}" ]]; then
    IFS=',' read -ra deps_array <<< "${deps}"
    for dep in "${deps_array[@]}"; do
      ((IN_DEGREE["${stack}"]++))
    done
  fi
done

# Find stacks with no dependencies
for stack in "${ALL_STACKS[@]}"; do
  if [[ ${IN_DEGREE["${stack}"]} -eq 0 ]]; then
    QUEUE+=("${stack}")
  fi
done

# Process queue
while [[ ${#QUEUE[@]} -gt 0 ]]; do
  current="${QUEUE[0]}"
  QUEUE=("${QUEUE[@]:1}")  # Remove first element
  SORTED_STACKS+=("${current}")
  
  # For each stack that depends on current, decrease in-degree
  for stack in "${ALL_STACKS[@]}"; do
    deps="${STACK_DEPS[${stack}]}"
    if [[ -n "${deps}" ]]; then
      IFS=',' read -ra deps_array <<< "${deps}"
      for dep in "${deps_array[@]}"; do
        if [[ "${dep}" == "${current}" ]]; then
          ((IN_DEGREE["${stack}"]--))
          if [[ ${IN_DEGREE["${stack}"]} -eq 0 ]]; then
            QUEUE+=("${stack}")
          fi
        fi
      done
    fi
  done
done

# Check for cycles
if [[ ${#SORTED_STACKS[@]} -ne ${#ALL_STACKS[@]} ]]; then
  echo "ERROR: dependency cycle detected in registry" >&2
  exit 1
fi

# Deploy stacks in order
SUCCEEDED=()
FAILED=()

for stack in "${SORTED_STACKS[@]}"; do
  stack_path="${STACK_PATHS[${stack}]}"
  if [[ ! "${stack_path}" =~ ^/ ]]; then
    stack_path="${ROOT_DIR}/${stack_path}"
  fi
  
  echo "== Deploying: ${stack} (${stack_path})"
  if "${ROOT_DIR}/_bin/deploy-stack" "${stack_path}"; then
    SUCCEEDED+=("${stack}")
  else
    echo "!! Deployment FAILED for: ${stack}" >&2
    FAILED+=("${stack}")
  fi
done

echo
echo "== Deployment summary =="

if ((${#SUCCEEDED[@]})); then
  echo "Succeeded:"
  for s in "${SUCCEEDED[@]}"; do
    echo "  - ${s}"
  done
else
  echo "No stacks were successfully deployed."
fi

if ((${#FAILED[@]})); then
  echo
  echo "Failed:"
  for s in "${FAILED[@]}"; do
    echo "  - ${s}"
  done
  exit 1
fi

exit 0
