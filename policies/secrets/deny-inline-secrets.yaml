apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
  name: deny-inline-secrets
  annotations:
    policies.kyverno.io/title: Deny Inline Secrets (Require External Secrets Operator)
    policies.kyverno.io/category: Secrets
    policies.kyverno.io/severity: critical
    policies.kyverno.io/subject: Secret, Pod, Deployment, StatefulSet
    policies.kyverno.io/description: >-
      Prevents creation of Secret resources with inline data values. All secrets
      must be sourced from 1Password via External Secrets Operator (ESO).
      This prevents secret leakage in git repositories and centralizes secrets
      management.
    hypyr.space/rationale: "https://github.com/cpritchett/homelab/blob/main/docs/adr/ADR-0004-secrets-management.md"
spec:
  validationFailureAction: Enforce
  background: true
  rules:
    # Rule 1: Block Secret resources with inline data (unless ESO-managed or approved)
    - name: deny-secret-with-inline-data
      match:
        any:
          - resources:
              kinds:
                - Secret
      preconditions:
        all:
          # Exclude kube-system, kube-public, kube-node-lease (system secrets)
          - key: "{{ request.object.metadata.namespace }}"
            operator: AnyNotIn
            value:
              - kube-system
              - kube-public
              - kube-node-lease
              - external-secrets  # ESO's own secrets allowed
          # Exclude Helm/Flux-managed secrets (temporary)
          - key: "{{ request.object.metadata.labels.\"app.kubernetes.io/managed-by\" || '' }}"
            operator: AnyNotIn
            value:
              - Helm
              - flux
      validate:
        message: >-
          Secret "{{ request.object.metadata.name }}" contains inline data which is
          prohibited. Secrets must be sourced from 1Password via External Secrets
          Operator (ExternalSecret resources). For temporary exceptions (bootstrap only),
          add annotation: secrets.hypyr.space/inline-approved="true"
        deny:
          conditions:
            all:
              # Block if .data or .stringData is present and non-empty
              - key: "{{ request.object.data || request.object.stringData || {} }}"
                operator: NotEquals
                value: {}
              # Unless approval annotation is present
              - key: "{{ request.object.metadata.annotations.\"secrets.hypyr.space/inline-approved\" || 'false' }}"
                operator: NotEquals
                value: "true"
              # And not marked as ESO-managed
              - key: "{{ request.object.metadata.labels.\"external-secrets.io/managed-by\" || '' }}"
                operator: NotEquals
                value: external-secrets

    # Rule 2: Require justification for approved inline secrets
    - name: require-inline-secret-justification
      match:
        any:
          - resources:
              kinds:
                - Secret
              annotations:
                secrets.hypyr.space/inline-approved: "true"
      validate:
        message: >-
          Secret "{{ request.object.metadata.name }}" is approved for inline data
          but missing required annotations:
          - secrets.hypyr.space/inline-justification: "<reason>"
          - secrets.hypyr.space/inline-expiration: "<date or trigger>"
        pattern:
          metadata:
            annotations:
              secrets.hypyr.space/inline-approved: "true"
              secrets.hypyr.space/inline-justification: "?*"
              secrets.hypyr.space/inline-expiration: "?*"

    # Rule 3: Warn about env vars with suspicious patterns (audit mode)
    - name: audit-suspicious-env-vars
      match:
        any:
          - resources:
              kinds:
                - Pod
                - Deployment
                - StatefulSet
                - DaemonSet
                - Job
                - CronJob
      validate:
        validationFailureAction: Audit  # Log but don't block
        message: >-
          Resource "{{ request.object.metadata.name }}" contains environment variables
          with potentially hardcoded secrets (matching patterns: PASSWORD, TOKEN, API_KEY,
          SECRET). Verify these are sourced from ExternalSecret resources, not hardcoded.
        deny:
          conditions:
            any:
              # Check for suspicious env var names with non-empty values
              # (This is a simplified check; extend with more patterns as needed)
              - key: "{{ request.object.spec.template.spec.containers[].env[?name=='PASSWORD' || name=='API_KEY' || name=='TOKEN' || name=='SECRET'].value || [] }}"
                operator: NotEquals
                value: []
